---
layout: post
title:  "Sweet Async Java Framework"
date:   2019-05-16 21:00:00 -0600
categories: tech
---
Earlier this year my Tech Lead wanted the team to try out an async library on our new project. It is a fun little library called [Reactor](https://projectreactor.io/). It is a non blocking io asynchronous library. The project we are working on has a moderate amount of io so Reactor sounded like a good idea.

The two of us sat down and pair programmed on the first story to incorporate Reactor. We explored the framework together. Found some really cool stuff and some weird stuff. Overall, I am really impressed with it. It has been performing superbly. Spring Boot has integrated with Reactor and provided [WebClient](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-webclient.html). Which makes this even better.

So Reactor sets up streams to move data through. It is also lazy and doesn't actually do anything until something subscribes to the stream. The streams are a mix of push/pull. The end subscriber will make a request to the next level up to say it wants some data. If that layer has any actively available it will then send it down to the subscriber. Otherwise, it will request to the next layer up for more data. And so on and so forth. Eventually it will hit a provider who will start pushing data back down through the stream. This is why it's called a push-pull hybrid. 

We hit some really weird behavior while testing. We had a use case where we wanted to add a buffer, `.bufferTimeout()`, to allow the lower layers to group data into fewer executions. The lower layers also were somewhat slow because they were making HTTP requests. We intentionally throttled them way back to not impact the recipient of the request. But the upper layers were pulling work from a queue. After a short amount of time, the stream would crash. The buffer timeout has some unique behavior where after the timeout period it tries to push data down with `.onNext()` but there are no current requests because the lower levels are still busy handling earlier HTTP requests. The current implementation of the buffer timeout throws an exception when this occurs. This was a little annoying but our use case of throttling the lower levels goes against what Reactor wants to do. So we implemented our own buffer timeout to handle the situation. That was quite the endeavor.

Building an implementation of a safe buffer timeout taught us a lot about how the guts of Reactor behaves. We were shocked when our first implementation was working as expected. We'd throw some load at it and it all appeared to work great. Then we'd bring the load back down and let it idle. Then seemingly out of no where the stream would crash. We took a deep dive look at our safe buffer timeout implementation. After adding a whole slew of log statements we found our bug. Got it corrected and it has been working great ever since. 

I feel like every time I mess around with Reactor I get to learn something new. In recent adventures I've been looking at how to do Enterprisey stuff inside Reactor. Like a future tutorial I'm working on for getting contextual logging, aka [MDC](https://www.slf4j.org/manual.html#mdc), working with Reactor.